The section:
* Evaluating the generality / future proofness of Domino's atoms
--> Took 11 algorithms "after the fact" and tried compiling them.
--> Many compiled, but required us to rewrite the algorithms because the compiler wasn't exactly smart.
--> It required us to: move guards outside, precompute stateless expressions, reduce packet variable counts, etc.
--> But it still compiled.
--> The ones that didn't were "near misses". Here's an example: trTCM.
--> But the near miss suggests a path to designing a universal instruction set.
--> if (g1) f1 ... if(g2) f2 ... and so on
--> What is the optimal stateful instruction set? 
-----------


==== % Why does trTCM not work here? Give a crisp reason ====

====Maybe describe the atom design process up front here=====
Move it up from lessons learned to the beginnings of the evaluation section

====Write up of whether atoms generalize======

It's natural to ask if atoms generalize. We had to go through a trial and error
process of extending the atoms to ensure they worked well (git commits
xxx---yyy illustrate this process). However, after this process was over, we
only had to add a multiply-accumulate atom (reqd. for performance queries). In
hindsight, this was a simple enough instruction that we should have added to
the original instruction set, but did not simply because there was no way to
implement the primary use case for a MAC (the RED algorithm) without getting
queue size information in the enqueue pipeline.

After this process was over, we found that we could use the Domino atom to map
new non-linear-in-state examples from the performance queries project. We also
found that it could map <whatever examples we are able to map when writing new
algorithms now>. We found that the instruction set also influences the
algorithms people actually write for these pieces of hardware (give some
examples here).

At the same time, there are algorithms that do not map. These are algorithms that
need floating points (e.g., CoDel), or need more involved computations in their
predicate (e.g., trTCM (I think)). Looking back, we find that the general pattern of
if (g1(s, p)) s=f1(s, p)
if (g2(s, p)) s=f2(s, p)
seems to work well as a {\em structure} for these computations. But the details
of it vary in terms of what we can do within each g and each f. In the cases
where we had to extend the atoms, we only had to change the $f$s and $g$s and
not the overall structure.

(Maybe express all atoms in terms of this structure.)

=====Additional feedback to strengthen generalizability discussion======

10. Add a subsection on the generalizability of the Domino atoms.
i.e., take the Domino atoms as of some time,
and talk about whether all the algorithms that we wrote afterward could map to those atoms/not

For instance, all the Domino code snippets, maybe STFQ in the PIFO paper,
several PIFO examples, and the shift register that Domino uses. It's fair to
say that the linear-in-state atom is also an example of generalizability
because we should have added RED and hence EWMA to the instruction set early
on. Could also add PIE etc.

OK, we can't add STFQ because we had to modify the atom a little bit to support
STFQ
(https://github.com/packet-transactions/domino-examples/commit/344a8f74bbfaf37d63c479354cec38a4db24e08a)
But I think DNS ttl change detection was an example of something where we didn't
have to modify the atom, but we'll have to rerurn it on the old atom to be sure.
Could add HULA to the list of Domino algorithms
Could also try implementing HashPipe and some more algorithms from SNAP,
and the papers that SNAP itself references.

11. talk about why things don't generalize beyond the glib reason that CoDel needs floating point.
Maybe separate the discussion into the structure of the atom and the details of the atom, i.e., all atom updates can be written out as if(guard) then atom. The detail is in how complicated a stateful guard is. This is a useful pattern to extract out of the atom design process. The structure is probably going to be future proof even if the stateful predicates themselves aren't

5. More Domino programs to improve generalizability discussion

4. Crisply state the boundaries of the systems, especially atoms. Why can't you do trTCM? CoDel is a little
bit of a glib example: no floating point isn't sufficiently satisfying as an explanation.

7. More examples showing the generalizability of Domino's atoms. Could add code listing of the Domino algorithms to the appendix.
