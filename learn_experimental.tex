\section{Experimental setup}

\label{s:experiment}
We describe our experimental procedure below.  First, we specify a set
of \textit{training scenarios}: a set of network configurations
(\S\ref{ss:nwkcfg}) that express the designer's imperfect model of the
network. Next, we specify an \textit{objective function}
(\S\ref{ss:objective}). Remy synthesizes a congestion-control protocol
that attempts to maximize the value of this function, averaged over
the set of training scenarios. Finally (\S\ref{ss:eval}), we specify a
\textit{testing scenario} of network configurations, which may be
similar or dissimilar to the training scenarios.

We evaluate the synthesized congestion-control protocol on the testing
scenario to assess the questions of this study---how easy is it to
``learn'' a network protocol to achieve desired goals, given an imperfect
model of the networks where it will ultimately be deployed?

%\S\ref{s:operational} describes homogenous experiments where the testing scenario
%differs from the training scenario in operational parameters alone (topology,
%workload, minimum RTT, and link speed), assuming that all senders in the
%network run the same congestion-control protocol. \S\ref{s:diversity} deals
%with heterogeneity and describes experiments where the testing and training
%sets contain senders running multiple congestion-control protocols.

\subsection{Training scenarios}
\label{ss:nwkcfg}
The training scenarios specify the set of network configurations that
the protocol-design process is given access to. Formally, a network
configuration specifies:

\begin{enumerate}
\item The topology: link rate and propagation delay of each link in the network.
\item The locations of senders and receivers within the topology, and the paths
      connecting the senders to the receivers.
\item A model of the workload generated by the application running
  at each endpoint. We use an on/off model for the workload, where a
  sender turns ``on'' for a certain duration (or transfer length) drawn
  from an exponential distribution, then turns ``off'' for an amount of
  time drawn from another exponential distribution before turning on
  again.
\item The buffer size and queue discipline at each gateway.
\end{enumerate}

\subsection{Objective function}
\label{ss:objective}
The objective function expresses the protocol designer's figure of
merit for the goodness of a congestion-control protocol. Many such
metrics have been proposed, including alpha-fair
throughput~\cite{Srikant}, flow completion time~\cite{dctcp},
throughput-over-delay~\cite{codelID}, or measures based on a
subjective opinion score~\cite{MOSCC}.

In this study, we specifically considered objective functions of the
form:
\begin{equation}
\log\left( \textrm{throughput} \right)  - \delta \log\left( \textrm{delay} \right)
\end{equation}

Here, ``throughput'' is the average information transmission rate of a
sender-receiver pair, defined as the total number of bytes
successfully delivered divided by the total time the sender was ``on''
and had offered load. The ``delay'' is the average per-packet delay of
packets in the connection, including propagation delay and queueing
delay. The $\delta$ factor expresses a relative preference between high throughput and low delay.

The protocol-design process works to maximize the \emph{sum} of the
objective function across all connections. The $\log$ in the objective
function expresses a preference for ``proportionally-fair'' resource
allocation---for example, it is worthwhile to cut one connection's
throughput in half, as long as this enables another connection's
throughput to be more-than-doubled.

\begin{comment}

\subsection{Protocol-design process}
\label{ss:learning}
We outline the Remy protocol-design tool briefly here, following the
treatment of~\cite{remy}. Remy models a congestion-control protocol as
a set of match-action rules, mapping between the state maintained by
the sender and an action to be executed. The ``state'' tracks a small
set of congestion signals, updated on every acknowledgment from the
receiver. The ``action'' specifies changes in the behaviour of the
congestion-control protocol.

To simplify learning, Remy assumes a piecewise-constant mapping, and
searches for the mapping that maximizes the average value of the
objective function across the training scenarios.  The mapping is
initialized to prescribe a default action for all memory values. Remy
then simulates the protocol on the training scenarios and uses the
simulation results---and the resulting value of the objective
function---to gradually refine the mapping.

For the experiments in this paper, the sender tracks four
congestion signals:
\begin{enumerate}
\item \texttt{rec\_ewma}: An exponentially-weighted moving average, or
  EWMA, of the interarrival times between acks with a weight of 1/8
  for new samples.
\item \texttt{slow\_rec\_ewma}: The same, but with a weight of 1/256
  for new samples, producing an average taken over a longer history.
\item \texttt{send\_ewma}: A moving average of the intersend time
  between sender timestamps echoed in the received ACKs, with a weight
  of 1/8 for new samples.
\item \texttt{rtt\_ratio}: The ratio of the most recent
  round-trip-time measurement and the minimum RTT seen so far.
\end{enumerate}

\subsection{Value of the congestion signals}

\label{s:signals}

We performed a measurement study to evaluate the value of each of
these four signals on the ultimate performance of a congestion-control
protocol. We selectively ``knocked out'' each signal in turn and
designed a new congestion-control protocol from scratch (missing that
signal), in order to observe the effect of losing the signal on the
protocol's ultimate behavior.

In our measurements, we found that each of these congestion signals
independently brought value to a congestion-control protocol. No
three-signal subset was as strong as using all four signals. The most
valuable signal---by which we mean the signal whose removal cause the
greatest harm to the ultimate performance---was the
\texttt{rec\_ewma}. This suggests that these protocols may gain
considerable value from understanding the short-term packet-arrival
dynamics at the receiver.

\subsection{The congestion response}

The action uses a window-based congestion-control protocol that
caps the number of packets in flight, with pacing to regulate the rate
at which an end host meters packets into the network. The action for
any value of the memory is a triplet that specifies:
\begin{enumerate}
\item A multiplier $m$ to the current value of the congestion window.
\item An increment $b$ to the current value of the congestion window.
\item A lower bound $\tau$ on the pacing interval between outgoing packet transmissions.
\end{enumerate}

To emphasize that the resulting protocol is a brute-force
approximation of the best algorithm for a given set of training
scenarios and objective function, we refer to such protocols as
``tractable attempts at optimal'' congestion control, or Tao
protocols.

\end{comment}

\subsection{Evaluation procedure}
\label{ss:eval}
To measure the difficulty of learning a congestion-control protocol
with an imperfect model of the eventual network, we choose a testing
scenario of network configurations and evaluate the RemyCC on it. All
evaluations are performed in the ns-2 simulator.\footnote{Using one
  simulator for training (Remy's internal simulator) and a different
  one for evaluation helps give confidence that the congestion-control
  protocols learned are robust to quirks in a simulator
  implementation.}

We compare the performance of RemyCCs optimized for an ``accurate''
model of the network against RemyCCs optimized for various
kinds of imperfect models, in order to measure how faithfully protocol
designers need to understand the network they are designing for. We
give the training and testing scenarios in a table.

For reference, we also compare the RemyCCs with two common schemes in wide use today:

\begin{enumerate}
\item TCP Cubic~\cite{cubic}, the default congestion-control protocol in Linux
\item Cubic over stochastic fair queueing and CoDel~\cite{CoDel}, an
  active-queue-management scheme that runs on bottleneck routers and
  assists endpoints in achieving a fairer and more efficient use of
  network resources
\end{enumerate}

