\subsection{Network-wide to switch-local queries}
\label{sec:network-to-switch-local}

The compiler partitions a network-wide query written over all packets at all
queues in the network (\Sec{language}) into switch-local queries to generate
switch-specific configurations. We achieve this in two steps. First, we
determine the {\em stream location}, \ie the set of switches that contribute
tuples to a stream, for the final output stream of query. For instance, the
output stream of a query that filters by switch id $s$ has a stream location
equal to the singleton set $s$. Second, we determine how to partition queries
with aggregation functions written over the entire network into switch-local
queries.
\Anirudh{Mohammad said he didn't get some sentence here. I don't know if it was
the first or second :). NG, can you read the above paragraph once carefully.}


\Para{Determining stream location for the final output stream.} The stream
location of {\ct \pktlog} is the set of all switches in the network. The stream
location of the output of a {\ct filter} is the set of switches implied by the
filter's predicate. Concretely, we evaluate the set of switches contributing
tuples to the output of a {\ct filter} operation through basic syntactic checks
of the form {\ct switch == X} on the {\ct filter} predicate.  We combine switch
sets for boolean combinators ({\ct or} and {\ct and}) inside filter predicates
using set operations (union and intersection respectively). The stream location
of the output
of a {\ct zip} operator is the intersection of the stream locations of the two
inputs.  Stream locations are unchanged by the {\ct map} and {\ct groupby}
operators.

The stream locations for the running example are shown in
\Fig{compiler-ast-manipulations}b. The stream location of {\ct \pktlog} is
the set of all network switches, but is restricted to just {\ct S1} and {\ct
S2} by the {\ct filter} in the query (left branch). This location is then propagated
to the root of the AST through the {\ct zip} operator in the query.

\Para{Partitioning network-wide aggregations.}
As described in \S\ref{sec:language}, we only permit aggregations that satisfy
one of three conditions: they operate independently on each switch, operate
independently on each packet, or are associative and commutative.
We describe below how we
check the first condition, failing which we simply check the last two
conditions syntactically: either the {\ct groupby} aggregates by {\ct uid}
(condition 2) or contains programmer annotations {\ct assoc} and {\ct comm}
(condition 3).

%TODO: The stuff on top still needs to be rewritten ...
To check if an aggregation operates independently on each switch, we label each
AST node with an additional boolean attribute, {\em switch-partitioned},
corresponding to whether the output stream has been partitioned by the switch
at which it appears. Intuitively, if a stream is switch-partitioned, we allow
packet-order-dependent aggregations over multiple packets of that stream;
otherwise, we do not.

Determining and propagating {\em switch-partitioned} through an AST is
straightforward. The base {\ct \pktlog} is not switch-partitioned. The {\ct
  filter} and {\ct zip} operators produce a switch-partitioned stream if their
output only appears at a single switch. The {\ct groupby} produces a
switch-partitioned stream if it aggregates by {\ct switch.} In all other cases,
the operators retain the operands' switch-partitioned attribute.

The switch-partitioned attributes for our running example are shown in
\Fig{compiler-ast-manipulations}c. The {\ct filter} produces output streams at
two switches, hence is not switch-partitioned. The {\ct groupby} aggregates by
{\ct switch} and hence is switch-partitioned. After the partitioning checks have
succeeded, we are left with a set of independent switch-local ASTs corresponding
to each switch location that the AST root operator appears in, \ie {\ct S1, S2}.
