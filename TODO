0. Address feedback from thesis defense that I wrote down on a piece of paper
5. More Domino programs.
8. Reduce text from each chapter's introduction.

10a. Add a multiply-accumulate atom to the Domino set. The only reason we
didn't add it to the original Domino paper was because queue size information
for RED was not available at enqueue. We knew of it all the way back to the
2013 HotNets paper.

10. Add a subsection on the generalizability of the Domino atoms.
i.e., take the Domino atoms as of some time,
and talk about whether all the algorithms that we wrote afterward could map to those atoms/not

For instance, all the Domino code snippets, maybe STFQ in the PIFO paper,
several PIFO examples, and the shift register that Domino uses. It's fair to
say that the linear-in-state atom is also an example of generalizability
because we should have added RED and hence EWMA to the instruction set early
on. Could also add PIE etc.

OK, we can't add STFQ because we had to modify the atom a little bit to support
STFQ
(https://github.com/packet-transactions/domino-examples/commit/344a8f74bbfaf37d63c479354cec38a4db24e08a)
But I think DNS ttl change detection was an example of something where we didn't
have to modify the atom, but we'll have to rerurn it on the old atom to be sure.
Could add HULA to the list of Domino algorithms
Could also try implementing HashPipe and some more algorithms from SNAP,
and the papers that SNAP itself references.

11. talk about why things don't generalize beyond the glib reason that CoDel needs floating point.
Maybe separate the discussion into the structure of the atom and the details of the atom, i.e., all atom updates can be written out as if(guard) then atom. The detail is in how complicated a stateful guard is. This is a useful pattern to extract out of the atom design process. The structure is probably going to be future proof even if the stateful predicates themselves aren't

12. Spend a decent amount of time explaining the machine model: packets come in, they are looked up, we carry out some action, and so on so forth.

13. Distinguish single-pipeline and multi-pipeline routers and clarify that we
only deal with the former here.

14. The term fixed-function is a bit misleading.

15. Proof of fixed-point algorithm in Marple

* Push In First Out, no hyphenation anywhere, or hyphenate throughout: be consistent
* Don't keep saying today in the text
* domino_banzai.tex could use some more work
* Don't need to overdo the C-like re: Domino. Instead, call it an imperative DSL.
* router's line rate, or line rate of routers, sounds better than line rate routers
* Consider substituting line rate with high speed or something similar
* fix up this single pipeline router vs multi-pipeline router business
* Make sure P4-16 and P4_{16} are consistent. Use one or the other, not both.
* Use semicolons as separators with care
* Be judicious with contractions
* Be consistent with the project names and abstraction names TODO

* Consider using the term streaming algorithms instead of data-plane algorithms? (WISH LIST)

High-level feedback from defense:
============

6. Clarifying what we lose by determining packet rank at enqueue alone, as opposed to changing it later at dequeue.
7. More examples showing the generalizability of Domino's atoms. Could add code listing of the Domino algorithms to the appendix.
8. Distinguish computational capabilities of a pipeline from information not being available. For instance, RED needs queue depth that is not available, but the EWMA operation itself is rather straightforward.
17. Clarify linear-in-state algorithm further.

More feedback:
==============
1. Killer app for programmability: Measurement maybe?
2. Bridging gap between applications and the network (could be one item in future work).
3. Distinguish between availability of state and the computation that actually happens on the state.
For instance, RED is limited by the availability of queue size information in the ingress pipeline,
while the RED computation is definitely possible using a simple multiply-and-accumulate atom.
4. Crisply state the boundaries of the systems, especially atoms. Why can't you do trTCM? CoDel is a little
bit of a glib example: no floating point isn't sufficiently satisfying as an explanation.
5. The middle plane of networking: add this to future work.
6. What are the abstraction disadvantages to determining the packet's priority at the enqueue? Correspondingly,
what are the implementation advantages to determining the packet's priority at the enqueue?
